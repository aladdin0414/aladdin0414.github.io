<!DOCTYPE html>
<html>

<head>
    <title>三阶魔方</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #tip {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            font-family: Arial, sans-serif;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 5px;
            pointer-events: none;
        }

        #scrambleButton {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        #scrambleButton:hover {
            background-color: #45a049;
        }
    </style>

</head>

<body>
    <!-- <div id="tip">Hold Ctrl to rotate cube</div> -->
    <button id="scrambleButton">Scramble</button>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/tween.umd.js"></script>
    <script>
        // 初始化场景、相机和渲染器
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // 启用阴影
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 使用软阴影
        document.body.appendChild(renderer.domElement);

        // 添加轨道控制器
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // 添加阻尼效果
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 20;
        // controls.maxPolarAngle = Math.PI / 2; // 限制相机不能旋转到平面底部
        // controls.minPolarAngle = 0; // 限制相机不能旋转到平面顶部
        controls.enableZoom = true; // 允许缩放
        controls.enablePan = true; // 允许平移
        controls.rotateSpeed = 1.0; // 旋转速度
        controls.zoomSpeed = 1.0; // 缩放速度
        controls.panSpeed = 1.0; // 平移速度

        // 创建魔方的材质
        const materials = [
            new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 100 }), // 红
            new THREE.MeshPhongMaterial({ color: 0x00ff00, shininess: 100 }), // 绿
            new THREE.MeshPhongMaterial({ color: 0x0000ff, shininess: 100 }), // 蓝
            new THREE.MeshPhongMaterial({ color: 0xffff00, shininess: 100 }), // 黄
            new THREE.MeshPhongMaterial({ color: 0xffa500, shininess: 100 }), // 橙
            new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 100 })  // 白
        ];

        // 创建灰色材质（用于内部面）
        const grayMaterial = new THREE.MeshPhongMaterial({
            color: 0x808080,
            shininess: 0
        });

        // 创建地面
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            shininess: 0,
            side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // 使平面水平
        ground.position.y = -10; // 将地面放在魔方下方
        ground.receiveShadow = true; // 接收阴影
        // scene.add(ground);

        // 魔方参数
        const cubeletSize = 1.8; // 小方块大小
        const gap = 0.2; // 间隙大小
        const spacing = cubeletSize + gap; // 总间距

        // 创建单个小方块
        function createCubelet(x, y, z) {
            const geometry = new THREE.BoxGeometry(cubeletSize, cubeletSize, cubeletSize);

            // 创建六个面的材质
            const cubeMaterials = [
                x === 1 ? materials[4] : grayMaterial,  // 右面 - 橙
                x === -1 ? materials[0] : grayMaterial, // 左面 - 红
                y === 1 ? materials[5] : grayMaterial,  // 顶面 - 白
                y === -1 ? materials[3] : grayMaterial, // 底面 - 黄
                z === 1 ? materials[1] : grayMaterial,  // 前面 - 绿
                z === -1 ? materials[2] : grayMaterial  // 后面 - 蓝
            ];

            const cubelet = new THREE.Mesh(geometry, cubeMaterials);
            cubelet.position.set(x * spacing, y * spacing, z * spacing);
            cubelet.castShadow = true; // 投射阴影
            return cubelet;
        }

        // 创建整个魔方
        const cube = new THREE.Group();
        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    const cubelet = createCubelet(x, y, z);
                    cube.add(cubelet);
                }
            }
        }
        scene.add(cube);

        // 添加坐标轴辅助器
        // const axesHelper = new THREE.AxesHelper(10);
        // scene.add(axesHelper);

        // 设置相机位置
        camera.position.set(30, 10, 0);
        camera.lookAt(0, 0, 0);


        // 添加环境光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        // 添加平行光
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true; // 启用阴影投射
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        scene.add(directionalLight);

        // 添加第二个平行光以增加光照效果
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight2.position.set(-5, -5, -5);
        scene.add(directionalLight2);

        // 在脚本开始处添加旋转状态标志
        let isRotating = false;

        let selectedCubelet = null;

        // 添加鼠标按下事件监听器
        document.addEventListener('pointerdown', (event) => {

            // 创建射线投射器
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            // 计算鼠标在标准化设备坐标中的位置
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // 设置射线投射器
            raycaster.setFromCamera(mouse, camera);

            // 检测射线与魔方小方块的相交
            const intersects = raycaster.intersectObjects(cube.children);

            if (intersects.length > 0) {
                controls.enabled = false;
                // 如果点击到了小方块，记录被选中的小方块
                selectedCubelet = intersects[0].object;
                // 记录起始点击位置
                startX = event.clientX;
                startY = event.clientY;
                lastDirection = '';
                console.log('选中了一个小方块');
            } else {
                selectedCubelet = null;
            }
        });

        let startX = 0;
        let startY = 0;
        let lastDirection = '';

        document.addEventListener('pointermove', (event) => {
            if (selectedCubelet && !lastDirection && !isRotating) {
                const deltaX = event.clientX - startX;
                const deltaY = event.clientY - startY;

                // 设置一个最小移动距离阈值，避免微小移动就触发
                const threshold = 10;

                if (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold) {
                    // 判断主要移动方向
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        lastDirection = deltaX > 0 ? '向右' : '向左';
                        // 水平旋转
                        rotateLayer(selectedCubelet, 'horizontal', lastDirection === '向右' ? 1 : -1);
                    } else {
                        lastDirection = deltaY > 0 ? '向下' : '向上';
                        // 垂直旋转
                        rotateLayer(selectedCubelet, 'vertical', lastDirection === '向下' ? 1 : -1);
                    }
                    console.log('滑动方向:', lastDirection);
                }
            }
        });

        document.addEventListener('pointerup', (event) => {
            controls.enabled = true;
            selectedCubelet = null;
        });

        // 添加键盘事件监听器
        document.addEventListener('keydown', (event) => {
            if (isRotating) return; // 如果正在旋转中，直接返回
            rotateCube(event.key);
        });

        // 添加打乱魔方的函数
        function scrambleCube(moves = 20) {
            if (isRotating) return;

            // 包含面旋转和整体旋转的操作
            const allMoves = [
                // 面旋转
                { type: 'layer', direction: 'vertical', value: 1 },    // 下滑
                { type: 'layer', direction: 'vertical', value: -1 },   // 上滑
                { type: 'layer', direction: 'horizontal', value: 1 },  // 右滑
                { type: 'layer', direction: 'horizontal', value: -1 }, // 左滑
                // { type: 'cube', key: 'w' },     // 整体向上
                // { type: 'cube', key: 's' },     // 整体向下
                // { type: 'cube', key: 'a' },     // 整体向左
                // { type: 'cube', key: 'd' },     // 整体向右
            ];

            let moveCount = 0;

            function makeNextMove() {
                if (moveCount >= moves) {
                    return; // 达到指定步数后停止
                }
                
                if (!isRotating) {
                    // 随机选择一个操作
                    const randomMove = allMoves[Math.floor(Math.random() * allMoves.length)];

                    if (randomMove.type === 'layer') {
                        // 随机选择一个非中心块的方块
                        let selectedCube;
                        let isCenter = false;
                        do {
                            selectedCube = cube.children[Math.floor(Math.random() * cube.children.length)];
                            const pos = selectedCube.getWorldPosition(new THREE.Vector3());
                            // 检查是否为中心块(至少有两个坐标接近0)
                            const isCenter = [Math.abs(pos.x), Math.abs(pos.y), Math.abs(pos.z)].filter(coord => Math.abs(coord) < 0.1).length >= 2;
                        } while (isCenter);

                        // 执行面旋转
                        rotateLayer(selectedCube, randomMove.direction, randomMove.value);
                    } else {
                        // 执行整体旋转
                        rotateCube(randomMove.key);
                    }
                    moveCount++;
                    // 等待当前动画完成后继续下一步
                    setTimeout(makeNextMove, 350);
                }
            }

            makeNextMove();
        }

        // 提取通用的旋转动画方法
        function animateRotation(rotationAxis, rotationAngle) {
            rotationAxis.normalize(); // 确保是单位向量
            const start = { angle: 0 };
            const end = { angle: rotationAngle };
            let previousAngle = 0;
            new TWEEN.Tween(start)
                .to(end, 300) // 持续 1000ms
                .easing(TWEEN.Easing.Linear.None) // 线性匀速 (模拟你原来固定step)
                .onUpdate(() => {
                    const deltaAngle = start.angle - previousAngle;
                    cube.rotateOnWorldAxis(rotationAxis, deltaAngle);
                    previousAngle = start.angle;
                })
                .onComplete(() => {
                    isRotating = false;
                })
                .start();
        }

        // 添加打乱按钮的事件监听器
        document.getElementById('scrambleButton').addEventListener('click', () => {
            scrambleCube(20); // 执行20次随机移动
        });

        function rotateCube(key) {
            if (key === 'ArrowDown' || key === 'ArrowUp' || key === 'w' || key === 's') {
                isRotating = true;
                const rotationDirection = key === 'ArrowUp' || key === 'w' ? -1 : 1;
                const cameraDirection = camera.position.clone().sub(cube.position).normalize();
                const { x: dirX, z: dirZ } = cameraDirection;
                const isMainlyX = Math.abs(dirX) > Math.abs(dirZ);
                const rotationAxis = isMainlyX ? new THREE.Vector3(0, 0, 1) : new THREE.Vector3(1, 0, 0);
                const rotationAngle = Math.PI / 2 * rotationDirection * (isMainlyX ? -Math.sign(dirX) : Math.sign(dirZ));

                animateRotation(rotationAxis, rotationAngle);
            }

            if (key === 'ArrowLeft' || key === 'ArrowRight' || key === 'a' || key === 'd') {
                isRotating = true;
                const rotationDirection = key === 'ArrowLeft' || key === 'a' ? -1 : 1;
                const rotationAxis = new THREE.Vector3(0, 1, 0);
                const rotationAngle = Math.PI / 2 * rotationDirection;
                animateRotation(rotationAxis, rotationAngle);
            }
        }

        // 提取旋转层的通用方法
        function rotateLayer(selectedCubelet, direction, rotationDirection) {
            isRotating = true;

            // 根据方向确定旋转轴和角度
            let rotationAxis, rotationAngle;
            if (direction === 'horizontal') {
                rotationAxis = new THREE.Vector3(0, 1, 0);
                rotationAngle = Math.PI / 2 * rotationDirection;
            } else {
                const cameraDirection = camera.position.clone().sub(cube.getWorldPosition(new THREE.Vector3())).normalize();
                const { x: dirX, z: dirZ } = cameraDirection;
                const isMainlyX = Math.abs(dirX) > Math.abs(dirZ);
                rotationAxis = isMainlyX ? new THREE.Vector3(0, 0, 1) : new THREE.Vector3(1, 0, 0);
                rotationAngle = Math.PI / 2 * rotationDirection * (isMainlyX ? -Math.sign(dirX) : Math.sign(dirZ));
            }

            // 找出所有在同一轴上的小方块
            const sameAxisCubelets = cube.children.filter(cubelet => {
                const projection = cubelet.getWorldPosition(new THREE.Vector3()).dot(rotationAxis);
                const selectedProjection = selectedCubelet.getWorldPosition(new THREE.Vector3()).dot(rotationAxis);
                return Math.abs(projection - selectedProjection) < 0.1;
            });

            // 创建旋转组
            const rotationGroup = new THREE.Group();

            // 将同轴小方块添加到旋转组
            sameAxisCubelets.forEach(cubelet => {
                const worldPosition = cubelet.getWorldPosition(new THREE.Vector3());
                const worldQuaternion = cubelet.getWorldQuaternion(new THREE.Quaternion());

                cube.remove(cubelet);
                rotationGroup.add(cubelet);

                cubelet.position.copy(worldPosition);
                cubelet.quaternion.copy(worldQuaternion);
            });

            scene.add(rotationGroup);

            // 创建旋转动画
            const start = { angle: 0 };
            const end = { angle: rotationAngle };
            let previousAngle = 0;

            // 保存旋转组中所有方块的引用
            const cubeletsInGroup = [...rotationGroup.children];

            new TWEEN.Tween(start)
                .to(end, 300)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(() => {
                    const deltaAngle = start.angle - previousAngle;
                    rotationGroup.rotateOnWorldAxis(rotationAxis, deltaAngle);
                    previousAngle = start.angle;
                })
                .onComplete(() => {
                    // 使用保存的引用来处理所有方块
                    cubeletsInGroup.forEach(cubelet => {
                        // 保存世界坐标
                        const worldPosition = cubelet.getWorldPosition(new THREE.Vector3());
                        const worldQuaternion = cubelet.getWorldQuaternion(new THREE.Quaternion());

                        // 从旋转组中移除
                        rotationGroup.remove(cubelet);
                        // 添加回魔方
                        cube.add(cubelet);

                        // 恢复世界坐标
                        // 将世界坐标转换为相对于cube的本地坐标
                        const localPosition = new THREE.Vector3();
                        const localQuaternion = new THREE.Quaternion();

                        // 获取cube的世界变换矩阵的逆矩阵
                        const cubeWorldMatrixInverse = new THREE.Matrix4();
                        cubeWorldMatrixInverse.copy(cube.matrixWorld).invert();

                        // 将世界坐标转换为相对于cube的本地坐标
                        localPosition.copy(worldPosition).applyMatrix4(cubeWorldMatrixInverse);
                        localQuaternion.copy(worldQuaternion).premultiply(cube.quaternion.clone().invert());

                        // 应用本地坐标
                        cubelet.position.copy(localPosition);
                        cubelet.quaternion.copy(localQuaternion);
                    });

                    // 从场景中移除旋转组
                    scene.remove(rotationGroup);
                    lastDirection = '';
                    isRotating = false;
                })
                .start();
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // 更新控制器
            TWEEN.update();
            renderer.render(scene, camera);
        }

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>
